#pragma once

namespace eastengine
{
	namespace graphics
	{
		class IEffect;
		class IEffectTech;

		class IRenderTarget;
		class ITexture;
		class IStructuredBuffer;
		class ISamplerState;

		struct OceanParameter
		{
			// Must be power of 2.
			int dmap_dim;
			// Typical value is 1000 ~ 2000
			float patch_length;

			// Adjust the time interval for simulation.
			float time_scale;
			// Amplitude for transverse wave. Around 1.0
			float wave_amplitude;
			// Wind direction. Normalization not required.
			math::Vector2 wind_dir;
			// Around 100 ~ 1000
			float wind_speed;
			// This value damps out the waves against the wind direction.
			// Smaller value means higher wind dependency.
			float wind_dependency;
			// The amplitude for longitudinal wave. Must be positive.
			float choppy_scale;
		};

		struct CB_Structure
		{
			uint32_t thread_count = 0;
			uint32_t ostride = 0;
			uint32_t istride = 0;
			uint32_t pstride = 0;
			float phase_base = 0.f;

			void Set(uint32_t _thread_count, uint32_t _ostride, uint32_t _istride, uint32_t _pstride, float _phase_base)
			{
				thread_count = _thread_count;
				ostride = _ostride;
				istride = _istride;
				pstride = _pstride;
				phase_base = _phase_base;
			}
		};

		struct CSFFT512x512_Plan
		{
			// More than one array can be transformed at same time
			uint32_t slices = 0;

			// For 512x512 config, we need 6 constant buffers
			CB_Structure radix008A_CB[6];

			// Temporary buffers
			IStructuredBuffer* pBuffer_Tmp = nullptr;
		};

		class WaterSimulator
		{
		public:
			WaterSimulator();
			~WaterSimulator();

			// -------------------------- Initialization & simulation routines ------------------------
			bool Init(OceanParameter& params);
			void Release();

			// Update ocean wave when tick arrives.
			void UpdateDisplacementMap(IDevice* pDevice, IDeviceContext* pDeviceContext, float fTime);

			// Texture access
			const std::shared_ptr<ITexture>& GetTextureDisplacementMap();
			const std::shared_ptr<ITexture>& GetTextureGradientMap();

			const OceanParameter& GetParameters() { return m_param; }

		private:
			// Initialize the vector field.
			void InitHeightMap(OceanParameter& params, math::Vector2* out_h0, float* out_omega);

			void ClearEffect(IDeviceContext* pd3dDeviceContext, IEffectTech* pEffectTech);
			void ClearEffect_FFT(IDeviceContext* pd3dDeviceContext, IEffectTech* pEffectTech);
			
			void radix008A(IDevice* pDevice, IDeviceContext* pDeviceContext, 
				IStructuredBuffer* pUAV_Dst,
				IStructuredBuffer* pSRV_Src,
				CB_Structure& structure,
				uint32_t thread_count,
				uint32_t istride);

			bool fft512x512_create_plan(CSFFT512x512_Plan* plan, uint32_t slices);
			void fft512x512_destroy_plan(CSFFT512x512_Plan* plan);

			void fft_512x512_c2c(IDevice* pDevice, IDeviceContext* pDeviceContext,
				CSFFT512x512_Plan* fft_plan,
				IStructuredBuffer* pUAV_Dst,
				IStructuredBuffer* pSRV_Dst,
				IStructuredBuffer* pSRV_Src);

		private:
			IEffect* m_pEffect;
			IEffect* m_pEffect_FFT;

			OceanParameter m_param;

			// ---------------------------------- GPU shading asset -----------------------------------
			// Displacement map
			IRenderTarget* m_pDisplacementMap;		// (RGBA32F)

			// Gradient field
			IRenderTarget* m_pGradientMap;			// (RGBA16F)

			// ----------------------------------- CS simulation data ---------------------------------

			// Initial height field H(0) generated by Phillips spectrum & Gauss distribution.
			IStructuredBuffer* m_pBuffer_Float2_H0;

			// Angular frequency
			IStructuredBuffer* m_pBuffer_Float_Omega;

			// Height field H(t), choppy field Dx(t) and Dy(t) in frequency domain, updated each frame.
			IStructuredBuffer* m_pBuffer_Float2_Ht;

			// Height & choppy buffer in the space domain, corresponding to H(t), Dx(t) and Dy(t)
			IStructuredBuffer* m_pBuffer_Float_Dxyz;


			ID3D11Buffer* m_pQuadVB;

			// FFT wrap-up
			CSFFT512x512_Plan m_fft_plan;

			ISamplerState* m_pSampler;

#ifdef CS_DEBUG_BUFFER
			ID3D11Buffer* m_pDebugBuffer;
#endif
		};
	}
}